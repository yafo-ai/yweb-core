"""测试主键生成时机

验证所有主键策略（自增、UUID、雪花算法、短UUID）都是在 flush 时生成。

注意：由于实现了 __getattribute__ 拦截 id 访问并自动 flush，
测试中使用 object.__getattribute__ 绕过拦截器来检查原始 id 值。

运行方式：
    python test_pk_generation_timing.py
"""

import os
import sys

# 添加项目路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from yweb.orm import (
    CoreModel,
    init_database,
    transaction_manager as tm,
    configure_primary_key,
    IdType,
)


def get_raw_id(obj):
    """绕过 __getattribute__ 获取原始 id 值，不触发自动 flush"""
    # 使用 object.__getattribute__ 绕过 CoreModel 的拦截器
    return object.__getattribute__(obj, 'id')


def test_auto_increment():
    """测试自增主键的生成时机"""
    print("\n" + "=" * 60)
    print("[Test 1] AUTO_INCREMENT")
    print("=" * 60)
    
    # 配置自增主键
    configure_primary_key(strategy=IdType.AUTO_INCREMENT)
    
    class UserAutoInc(CoreModel):
        __tablename__ = "test_user_auto_inc"
        name: Mapped[str] = mapped_column(String(50))
    
    # 创建表
    from yweb.orm import get_engine
    UserAutoInc.metadata.create_all(get_engine())
    
    with tm.transaction():
        # 步骤1: 创建对象
        user = UserAutoInc(name="ZhangSan")
        raw_id = get_raw_id(user)
        print(f"1. After create: id = {raw_id}")
        assert raw_id is None, "id should be None after create"
        
        # 步骤2: 添加到 session（不 flush）
        user.add()
        raw_id = get_raw_id(user)
        print(f"2. After add(): id = {raw_id}")
        assert raw_id is None, "id should be None after add()"
        
        # 获取 session，手动检查状态
        session = tm.get_session()
        print(f"   - In session.new: {user in session.new}")
        assert user in session.new, "should be in session.new (pending)"
        
        # 步骤3: 手动 flush
        session.flush()
        raw_id = get_raw_id(user)
        print(f"3. After flush(): id = {raw_id}")
        assert raw_id is not None, "id should have value after flush"
    
    print("[PASS] AUTO_INCREMENT: id generated by database during flush")


def test_uuid():
    """测试 UUID 主键的生成时机"""
    print("\n" + "=" * 60)
    print("[Test 2] UUID")
    print("=" * 60)
    
    # 配置 UUID 主键
    configure_primary_key(strategy=IdType.UUID)
    
    class UserUUID(CoreModel):
        __tablename__ = "test_user_uuid"
        name: Mapped[str] = mapped_column(String(50))
    
    # 创建表
    from yweb.orm import get_engine
    UserUUID.metadata.create_all(get_engine())
    
    with tm.transaction():
        # 步骤1: 创建对象
        user = UserUUID(name="LiSi")
        raw_id = get_raw_id(user)
        print(f"1. After create: id = {raw_id}")
        assert raw_id is None, "id should be None after create"
        
        # 步骤2: 添加到 session（不 flush）
        user.add()
        raw_id = get_raw_id(user)
        print(f"2. After add(): id = {raw_id}")
        assert raw_id is None, "id should be None after add()"
        
        # 获取 session，手动检查状态
        session = tm.get_session()
        print(f"   - In session.new: {user in session.new}")
        assert user in session.new, "should be in session.new (pending)"
        
        # 步骤3: 手动 flush
        session.flush()
        raw_id = get_raw_id(user)
        print(f"3. After flush(): id = {raw_id}")
        assert raw_id is not None, "id should have value after flush"
        assert len(raw_id) == 36, f"UUID should be 36 chars, got {len(raw_id)}"
    
    print("[PASS] UUID: id generated in before_insert event during flush")


def test_snowflake():
    """测试雪花算法主键的生成时机"""
    print("\n" + "=" * 60)
    print("[Test 3] SNOWFLAKE")
    print("=" * 60)
    
    # 配置雪花算法主键
    configure_primary_key(
        strategy=IdType.SNOWFLAKE,
        snowflake_worker_id=1,
        snowflake_datacenter_id=1
    )
    
    class UserSnowflake(CoreModel):
        __tablename__ = "test_user_snowflake"
        name: Mapped[str] = mapped_column(String(50))
    
    # 创建表
    from yweb.orm import get_engine
    UserSnowflake.metadata.create_all(get_engine())
    
    with tm.transaction():
        # 步骤1: 创建对象
        user = UserSnowflake(name="WangWu")
        raw_id = get_raw_id(user)
        print(f"1. After create: id = {raw_id}")
        assert raw_id is None, "id should be None after create"
        
        # 步骤2: 添加到 session（不 flush）
        user.add()
        raw_id = get_raw_id(user)
        print(f"2. After add(): id = {raw_id}")
        assert raw_id is None, "id should be None after add()"
        
        # 获取 session，手动检查状态
        session = tm.get_session()
        print(f"   - In session.new: {user in session.new}")
        assert user in session.new, "should be in session.new (pending)"
        
        # 步骤3: 手动 flush
        session.flush()
        raw_id = get_raw_id(user)
        print(f"3. After flush(): id = {raw_id}")
        assert raw_id is not None, "id should have value after flush"
        assert isinstance(raw_id, int), f"Snowflake ID should be int, got {type(raw_id)}"
    
    print("[PASS] SNOWFLAKE: id generated in before_insert event during flush")


def test_short_uuid():
    """测试短UUID主键的生成时机"""
    print("\n" + "=" * 60)
    print("[Test 4] SHORT_UUID")
    print("=" * 60)
    
    # 配置短UUID主键
    configure_primary_key(strategy=IdType.SHORT_UUID, short_uuid_length=10)
    
    class UserShortUUID(CoreModel):
        __tablename__ = "test_user_short_uuid"
        name: Mapped[str] = mapped_column(String(50))
    
    # 创建表
    from yweb.orm import get_engine
    UserShortUUID.metadata.create_all(get_engine())
    
    with tm.transaction():
        # 步骤1: 创建对象
        user = UserShortUUID(name="ZhaoLiu")
        raw_id = get_raw_id(user)
        print(f"1. After create: id = {raw_id}")
        assert raw_id is None, "id should be None after create"
        
        # 步骤2: 添加到 session（不 flush）
        user.add()
        raw_id = get_raw_id(user)
        print(f"2. After add(): id = {raw_id}")
        assert raw_id is None, "id should be None after add()"
        
        # 获取 session，手动检查状态
        session = tm.get_session()
        print(f"   - In session.new: {user in session.new}")
        assert user in session.new, "should be in session.new (pending)"
        
        # 步骤3: 手动 flush
        session.flush()
        raw_id = get_raw_id(user)
        print(f"3. After flush(): id = {raw_id}")
        assert raw_id is not None, "id should have value after flush"
        assert len(raw_id) == 10, f"Short UUID should be 10 chars, got {len(raw_id)}"
    
    print("[PASS] SHORT_UUID: id generated in before_insert event during flush")


def test_auto_flush_on_id_access():
    """测试访问 id 属性时自动 flush"""
    print("\n" + "=" * 60)
    print("[Test 5] Auto flush on id access")
    print("=" * 60)
    
    # 使用自增主键测试
    configure_primary_key(strategy=IdType.AUTO_INCREMENT)
    
    class UserAutoFlush(CoreModel):
        __tablename__ = "test_user_auto_flush"
        name: Mapped[str] = mapped_column(String(50))
    
    # 创建表
    from yweb.orm import get_engine
    UserAutoFlush.metadata.create_all(get_engine())
    
    with tm.transaction():
        user = UserAutoFlush(name="TestUser")
        user.save()  # save() without commit
        
        # 检查 flush 前的状态（使用 get_raw_id 绕过拦截器）
        raw_id_before = get_raw_id(user)
        print(f"1. After save(), raw id (bypass interceptor): {raw_id_before}")
        
        # 直接访问 user.id（会触发 __getattribute__ 拦截器，自动 flush）
        user_id = user.id
        print(f"2. Access user.id (triggers auto flush): {user_id}")
        
        assert user_id is not None, "Accessing id should trigger auto flush"
    
    print("[PASS] Auto flush: accessing id triggers automatic flush")


def main():
    """运行所有测试"""
    print("=" * 60)
    print("Primary Key Generation Timing Test")
    print("=" * 60)
    
    # 初始化内存数据库
    init_database("sqlite:///:memory:", echo=False)
    
    try:
        test_auto_increment()
        test_uuid()
        test_snowflake()
        test_short_uuid()
        test_auto_flush_on_id_access()
        
        print("\n" + "=" * 60)
        print("ALL TESTS PASSED!")
        print("=" * 60)
        print("\nConclusion:")
        print("- All primary keys are generated during flush")
        print("- AUTO_INCREMENT: generated by database during INSERT")
        print("- UUID/SNOWFLAKE/SHORT_UUID: generated in before_insert event")
        print("- Accessing id attribute triggers automatic flush")
        
    except AssertionError as e:
        print(f"\n[FAIL] {e}")
        return 1
    except Exception as e:
        print(f"\n[ERROR] {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
